chapter05. 

클래스
===========

## 객체 지향 프로그래밍
현실 세계에서 어떤 제품을 만들때, 부품을 먼저 개발하고 이 부품들을 하나씩 조립해서 완성된 제품을 만들 듯이,
소프트웨어를 개발할 때에도 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을
객체 지향 프로그래밍(OOP: Object Oriented Programming) 이라고 한다.

### 객체란?
+ 객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.
+ 예를 들어 물리적으로 존재하는 자동차, 자전거, 책, 사람과 추상적인 학과, 강의, 주문 등이 모두 객체가 될 수 있다.
+ 객체는 속성과 동작으로 구성되어 있다. 사람은 이름, 나이 등의 속성과 웃다, 걷다 등의 동작이 있고, 자동차는 색상, 모델명 등의 속성과
달린다, 멈춘다 등의 기능이 있다.
+ 자바 에서는 이 속성과 동작들을 각각 필드(field)와 메소드(method)라고 부른다.

+ 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링(Object Modeling)이라고 한다.

### 객체의 상호작용
+ 현실 세계에서 일어나는 모든 현상은 각체 간의 상호작용으로 이루어져 있다. 예를 들어 사람은 전자계산기의 기능을 이용하고,
전자계산기는 계산 결과를 사람에게 알려주는 상호작용을 한다.
+ 소프트웨어도 마찬가지다. 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작한다.
+ 객체가 다른 객체의 기능을 이용하는 것이 바로 메소드 호출이다.
  
.

    int result = Calculator.add(10,20);
    //리턴한 값을 int 변수에 저장


### 객체 간의 관계
+ 객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다. 이 관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다.
+ 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다. 예를 들어 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 이 부품들은 
집합의 관계라고 볼수 있다.
+ 사용 관계는 객체 간의 상호작용을 말한다. 예를 들어 사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계라고 볼 수 있다.
+ 상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다. 일반적으로 상위 객체는 종류를 의미하고,
하위 객체는 구체적인 사물에 해당한다. 예를 들어 "자동차는 기계의 종류이다." 에서 기계(상위)와 자동차(하위)는 상속 관계에 있다고 볼 수 있다.
+ 객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를
하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법이다.

## 객체 지향 프로그래밍의 특징
객체 지향 프로그램의 특징으로는 캡슐화, 상속, 다형성을 들 수 있다.

### 캡슐화(Encapsulation)
캡술화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다.
외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

<img src = "https://t1.daumcdn.net/cfile/tistory/2614B34D5874E1D809"></img>

+ 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. 
예를 들어 TV의 중요한 부품이 바깥으로 노출되어 있다면, 사용자의 실수로 인해 고장날 수도 있다.
이런 부품은 함부로 만지지 못하게 TV 안쪽으로 캡슐화하여 숨겨두어야 한다.
+ 자바 언어는 캡슐화된 맴버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.
접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.


### 상속(Inheritance)
객체 지향 프로그래밍에서는 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다.
상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다.

<img src = "http://thumbnail.egloos.net/600x0/http://pds18.egloos.com/pds/201108/04/35/d0110135_4e3a3576ee770.jpg"></img>

+ 상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에
반복된 코드의 중복을 줄여준다.


### 다형성(Polymorphism)
다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 
코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.

<img src = "https://t1.daumcdn.net/cfile/tistory/2535B84F55E3DAAD2B"></img>

+ 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고,
인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.

## 객체와 클래스
현실에서 객체는 설계도를 바탕으로 만들어진다. 사람들이 자동차를 이용하기 위해서는 우선 공장에서 설계도를 보고 자동차를 만들어야 한다.   
객체 지향 프로그래밍에서도 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다.
자바에서는 설계도가 바로 클래스(class)이다.   
클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.   
객체 지향 프로그래밍 개발은 세 가지 단계가 있다. 첫 번째 단계는 클래스를 설계해야 한다. 
두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야한다. 마지막 단계는 생성된 객체를 이용하는 것이다.


## 클래스 선언
사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 한다. 예를 들어 사람 객체의 클래스는 Person으로,
자동차 객체의 클래스는 Car라는 이름으로 줄 수 있다.

    public class Car{
    
    }
    
+ public class 키워드는 클래스를 선언할 때 사용하며 반드시 소문자로 작성해야 한다. 
+ 중괄호 시작 {은 클래스 선언의 시작을 알려주고 중괄호 끝 }은 클래스 선언의 끝을 알려준다. 
+ 일반적으로 소스 파일당 하나의 클래스를 선언하지만 두개 이상의 클래스 선언도 가능하다. 하지만 파일 이름과 일치하지 않는 클래스 선언에
public 접근 제한자를 붙이면 컴파일 에러가 발생한다. 가급적이면 소스파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋다.


## 객체 생성과 클래스 변수
클래스를 선언한 다음, 컴파일을 했다면 객체를 생성할 설계도가 만들어진 셈이다.
클래스로부터 객체를 생성하는 방법은 new 연산자를 사용하면 된다.

    new 클래스();

new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.   
new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다. 
이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.

    클래스 변수 = new 클래스();


## 클래스의 구성 멤버
클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(method)가 있다.

    public class ClassName{
        
        //필드: 객체의 데이터가 저장되는 곳
        int fieldName;
        
        //생성자: 객체 생성 시 초기화 역할 담당
        ClassName() {...}
        
        //메소드: 객체의 동작에 해당하는 실행 블록
        void methodName(){...}
    }

### 필드
+ 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지 않는다.
+ 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

### 생성자
+ 생성자는 new 연산자로 호출되는 중괄호 {} 블록이다. 생성자의 역할은 객체 생성 시 초기화를 담당한다.
+ 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.
+ 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다.

### 메소드
+ 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다.
+ 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
+ 메소드는 객체 간의 데이터 전달의 수단으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.

## 필드
























