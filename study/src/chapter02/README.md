chapter 02.

연산자
==============
### 연산자와 연산식
프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산이라고 한다.   
연산에 사용되는 표시나 기호를 연산자라고 하고, 연산되는 데이터는 피연산자라고 한다.   
예를 들어 다음 연산식에서 +, -, *, == 은 연산자이고 x, y, z 변수는 피연산자이다.   
   
     x + y
     x - y
     x * y + z
     x == y
     
보통 연산식의 값은 변수에 저장하는데, 다음과 같이 x와 y 변수의 값을 더하고 나서 result 변수에 저장한다.

    int result = x + y;
    
먼저 연산하고 싶은 부분이 있으면 괄호()를 사용하여 묶으면 된다.

    int var1 = 1;
    int var2 = 3;
    int var3 = 2;
    int result = (var1 + var2) * var3;
   
   
   
단항연산자
================
단항 연산자는 피연산자가 단 하나뿐인 연산자를 말한다.(부호, 증감, 논리 부정, 비트 반전 연산자)

### 부호 연산자(+,-)
부호 연산자는 양수 및 음수를 표시하는 +,- 를 말한다. boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용할 수 있다.
부호 연산자를 정수 및 실수 리터럴 앞에 붙여 양수 및 음수를 표현한다.

    int i1 = +100;
    int i2 = -100;
    double d1 = +3.14;
    double d2 = -10.5;

부호 연산자를 사용시 주의할 점은 부호 연산자의 산출 타입은 int 타입이 된다는 것이다.   

    short s = 100;
    short result = -s;    //컴파일 에러
    int result2 = -s;

### 증감 연산자(++,--)
증감 연산자는 변수의 값을 1증가(++) 시키거나 1 감소(--) 시키는 연산자를 말한다.   
증감 연산자가 변수 앞에 있으면 우선 변수를 1증가 또는 1감소 시킨 후에 다른 연산자와 계산한다.   
증감 연산자가 변수 뒤에 있으면 다른 연산자를 먼저 처리한후 변수를 1증가 또는 1감소 시킨다.

    int x = 1;
    int y = 1;
    int result1 = ++x + 10;
    int result2 = y++ + 10;
    변수 result1 에는 12가 저장된다. 그 이유는 증가 연산자가 앞에 있기 때문에 먼저 1이 증가되기 때문이다.
    변수 result2 에는 11가 저장된다. 그 이유는 증가 연산자가 뒤에 있기 때문에 다른 연산먼저 실행되고 1이 증가되기 때문이다.
    

### 논리 부정 연산자(!)
논리 부정 연산자는 true를 false로 false를 true 로 변경하기 때문에 boolean 타입에만 사용할 수 있다.
조건문과 제어문에서 사용되며 두가지 상태(true/false)를 번갈아가며 변경하는 토글 기능을 구현할 때도 주로 사용한다.

### 비트 반전 연산자(~)
비트 반전 연산자는 정수 타입(byte, short, int ,long)의 피연산자에만 사용 되며, 피연산자를 2진 수로 표현했을 때   
비트값인 0을 1로, 1은 0으로 반전한다. 연산 후, 부호 비트인 최상위 비트를 포함해서 모든 비트가 반전되기 때문에,   
부호가 반대인 새로운 값이 산출된다.

비트 반전 연산자를 사용할 때 주의할 점은 비트 반전 연산자 산출 타입은 int 타입이 된다는 것이다.

    byte v1 = 10;
    byte v2 = ~v1; //컴파일 에러
    int v3 = ~v1;
    
비트 반전 연산자의 결과를 이용하면 부호가 반대인 정수를 구할 수도 있다. 산출값에 1을 더하면 부호가 반대인 정수를 얻을 수 있다.

    byte v1 = 10;
    int v2 = ~v1 + 1; //-10이 v2에 저장


이항 연산자
===============
이항 연산자는 피연산자가 두 개인 연산자를 말하며 여기에는 산술 연산자, 문자열 연결 연산자, 대입연산자, 비교연산자, 논리 연산자, 비트 논리 연산자,
비트 이동 연산자 등이 있다.

### 산술 연산자(+, -, *, /, %)
우리가 일반적으로 말하는 사칙연산인 더하기(+), 빼기(-), 곱하기(*), 나누기(/)와 나머지를 구하는 연산자(%)를 포함해서 산술 연산자는 총 5개 이다.   
long을 제외한 정수 타입 연산은 int 타입으로 산출되고, 피연산자 중 하나라도 실수 타입이면 실수 타입으로 산출된다.

    byte byte1 = 1;
    byte byte2 = 1;
    byte byte3 = byte1 + byte2; //컴파일 에러
    int result1 = byte 1 + byte2; 

산출 결과를 실수로 얻고 싶다면 피연산자 중 최소한 하나는 실수 타입이어야 한다.
    int int1 = 10;
    int int2 = 4;
    int result2 = int1 / int2;  //산출값 2
    double result3 = int1 / int2;  //산출값 2.0
    
    double result4 = (int1*1.0) / int2;       //산출값 2.5
    double result5 = (double) int1 / int2;    //산출값 2.5
    double result6 = int1 / (double) int2;    //산출값 2.5
    
char 타입도 정수 타입이므로 산술 연산이 가능 하지만 산술 연산이 될 경우 int 타입으로 변환되므로 산출 타입도 int 타입이다.

### 산술 연산 중 주의할 점 
+ 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다. 산출 타입으로 표현할 수 없는 값이 산출되었을 경우
오버플로우가 발생하고 쓰레기값을 얻을 수 있기 때문이다.

+ 정확하게 계산해야 할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다.

### 문자열 연결 연산자(+)
문자열 연결 연산자인 +는 문자열을 서로 결함하는 연산자이다. 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를
문자열로 변환하고 서로 결합한다.

    String str1 = "JDK" + 6.0;    //"JDK6.0"
    String str2 = str1 + "특징";  //"JDK6.0 특징"

문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행된다.

    "JDK" + 3 + 3.0;  //"JDK33.0"
    3 + 3.0 + "JDK";  //"6.0JDK"

### 비교 연산자(<. <=, >, >=, ==, !=)
비교 연산자는 대소(<, <=, >, >=) 또는 동등(==, !=)을 비교해서 boolean 타입인 true/false를 산출한다.   
비교 연산자는 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 이용되어 실행 흐름을 제어할 때 사용된다.   
비교 연산자에서도 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킨다.

    'A' == 65 -> true  //A가 int 타입으로 변환되어 65가 된다음 65==65로 비교한다.
    3 == 3.0 -> true   //3은 int 타입이고 3.0은 double 타입 이므로 3을 double 타입으로 변환한 다음 3.0==3.0으로 비교한다.
    
한 가지 예외가 있는데, 0.1==0.1f와 같은 경우 0.1f가 double 타입으로 변환되어 0.1==0.1이 되고 true가 산출되어야 하지만,
false가 산출된다.

    0.1 == 0.1f -> false

그 이유는 부동소수점 타입은 0.1을 정확히 표현할 수가 없어서 0.1f는 0.1의 근사값으로 표현되어 0.100000000149011612와 같은 값이 되기 때문에
0.1 보다 큰 값이 되어버린다. 이런 경우 피연산자를 모두 float 타입으로 강제 타입 변환후 비교 연산을 하거나, 정수로 변환해서 비교하면 된다.   

String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없고, 동등 비교 연산자는 사용할 수 있으나 문자열이 같은지, 다른지를 비교하는 용도로는 사용되지 않는다.

    String strVar1 = "Java";
    String strVar2 = "Java";
    String strVar3 = new String("Java");
    strVar1 == strVar2 -> true;
    strVar2 == strVar3 -> false;

자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어 있기 때문에 변수 strVar1과 strVar2는 동일한 String 객체의 번지값을 가지고 있다. 그러나 변수 strVar3은 객체 생성 연산자인 new로 생성한 새로운 String 객체의 번지값을 가지고 있다.   
String 객체의 문자열만을 비교하고 싶다면 == 연산자 대신에 equals() 메소드를 사용해야 한다. equals() 메소드는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한 후 true 또는 false를 리턴한다.

    strVar1.equals(strVar2)  -> true
    strVar2.equals(strVar3)  -> true


### 논리 연산자(&&, ||, &, |, ^, !)
논리 연산자는 논리곱(&&), 논리합(||), 베타적 논리합(^) 그리고 논리 부정(!) 연산을 수행한다. 논리 연산자는 boolean 타입만 사용할 수 있다.   
논리 연산은 흐름 제어문인 조건문(if), 반복문(for, while) 등에 서 주로 사용된다.

    int charCode = 'A';
    if( (charCode >= 65) && (charCode <=90) )

### 비트 연산자(&, |, ^, ~, <<, >>, >>>)
비트 연산자는 데이터를 비트 단위로 연산한다.즉 0과 1이 피연산자가 된다. 그렇기 때문에 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.   기능에 따라 비트 논리 연산자(&, |, ^, ~)와 비트 이동 연산자(<<, >>, >>>)로 구분한다.   
비트 논리 연산자는 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고, 피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용된다.   
예를 들어 45와 25를 비트 논리 연산해보자.

    00101101  //45를 2진수로 표현
        &     //두 비트 모두 1일 경우 연산 결과가 1
    00011001  //25를 2진수로 표현'
        ↓
    00001001  //9
    ---------------
    00101101  //45를 2진수로 표현
        &     //두 비트 중 하나만 1일 경우 연산 결과가 1
    00011001  //25를 2진수로 표현
        ↓
    00111101  //61   
    ---------------
    00101101  //45를 2진수로 표현
        ^     //두 비트 중 하나는 1이고 다른 하나가 0일경우 연산 결과가 1
    00011001  //25를 2진수로 표현
        ↓
    00110100  //52   
    ---------------
    ~00101101  //45를 2진수로 표현
        ↓
    11010010
비트 연산자는 피연삱를 int 타입으로 자동 타입 변환한 후 연산을 수행한다. 그렇기 때문에 byte, short, char 타입을 비트 논리 연산하면   
결과는 int 타입이 된다.

    byte num1 = 45;
    byte num2 = 25;
    byte result = num1 & num2; //컴파일 에러
    int result = num1 & num2;

비트 이동 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

    a << b 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다.)
    a >> b 정수 a의 각 비트를 b 만큼 오른쪽으로 이동(빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워진다.
    a >>> b 정수 a의 각 비트를 b 만큼 오른쪽으로 이동(빈자리는 0으로 채워진다.)
   
### 대입 연산자(=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)

대입 연산자는 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다.   
오른쪽 피연산자는 리터럴 및 변수, 그리고 다른 연산식이 올수 있다.   
[대입 연산자 종류](https://t1.daumcdn.net/cfile/tistory/245A414E5535117B2B)

    int result = 0;
    result += 10;   //result 변수에 10이 더해지고 저장된다.

삼항 연산자
================
삼항 연산자(?:)는 세 개의 피연산자가 필요로 하는 연산자를 말한다. 삼항 연산자는 ? 앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다.

    int score = 95;
    char grade = (score>90) ? 'A' : 'B' //true가 나오면 'A' 가 저장되고 false가 나오면 'B'가 저장된다.

    





































