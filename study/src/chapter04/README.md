chapter 04.

참조타입
==========

### 데이터 타입 분류
자바의 데이터 타입에는 크게 기본 타입(primitive type)과 참조 타입(reference type)으로 분류된다. 기본 타입이란 정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다.    
지금 까지는 기본 타입으로 변수를 선언하고 데이터를 저장 했지만, 이번 장부터는 참조 타입에 중점을 둔다. 참조 타입이란 객체의 번지를 참조하는 타입으로
배열, 열거, 클래스, 인터페이스 타입을 말한다.

<img src = "https://t1.daumcdn.net/cfile/tistory/2244BE435640882F0D" witdth = "600" height = "400"></img>


기본 타입 으로 선언된 변수는 실제 값을 변수 안에 저장하지만, 참조 타입으로 선언된 변수는 메모리의 번지를 값으로 갖는다. 번지를 통해 객체를 참조
한다는 뜻에서 참조 타입이라고 부룬다.   

    [기본 타입 변수]    변수는 스택에 생성된다.
    int age = 25;
    double price = 100.5;
    
    [참조 타입 변수]    객체는 힙 역역에 생성된다.
    String name = "Java";
    String hobby = "독서";

int와 double 변수인 age와 price는 직접 값을 저장하고 있지만 String 클래스 변수인 name과 hobby는 힙 역영의 String 객체 주소 값을 가지고 있다.

## 메모리 사용 영역
JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역을 다음과 같이 세부 영역으로 구분해서 사용한다.

<img src = "https://t1.daumcdn.net/cfile/tistory/254CA24B56B7AA7A20"></img>

### 메소드(Method) 영역
+ 메소드 영역에는 코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스별로 런타임 상수풀, 필드 데이터, 메소드 데이터, 메소드 코드, 
생성자 코드 등을 분류해서 저장한다.
+ 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.

### 힙(Heap) 영역
+ 힙 영역은 객체와 배열이 생성되는 영역이다.
+ 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
+ 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 이것을 쓰레기로 취급하고 JVM은 쓰레기 수집기(Garbage Collector)를 실행시켜 쓰레기
객체를 힙 영역에서 자동으로 제거한다.
  
### JVM 스택(Stack) 영역
+ JVM 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.
+ 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하므로 JVM스택도 하나이다.
+ JVM 스택은 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
+ 예외 발생 시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.
+ 프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가 되거나 제거 된다. 변수가 이 영역에 생성되는 시점은 초기화가 될때,
즉 최초로 변수에 값이 저장될 때이다. 
  
변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

    char v1 = 'A';        // 스택에 추가
    
    if(v1=='A'){
    int v2 = 100;         // 스택에 추가
    double v3 = 3.14;     // 스택에 추가
    } //스택에서 v2와 v3를 제거
    
    boolean v4 = true;    //스택에 추가


참조 타입 변수는 값이 아니라 힙 영역이나 메소드 영역의 객체 주소를 가진다.

    int[] scores = {10, 20, 30};

위에 코드에서 scores는 스택 영역에 생성되지만 실제 10, 20, 30을 갖는 배열은 힙 영역에 생성된다. 배열 변수 scores에는 배열의 힙 영역의
주소가 저장된다.

### 참조 변수의 ==, != 연산

+ 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 == !=연산은 동일한 객체를 참조하는지,
다른 객체를 참조하는지 알아볼 때 사용된다.
  
==와 != 연산자로 객체를 비교하는 코드는 일반적으로 if문에서 많이 사용된다.

    refvar1 = 객체1;
    refvar2 = 객체2;
    refvar3 = 객체2;
    
    refvar1 == refvar2  결과 : false
    refvar1 != refvar2 결과 : true
    
    refvar2 == refvar3 결과 : true
    refvar2 != refvar3 결과 : false
   

### null과 NullPointerException
참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. null 값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조
변수는 스택 영역에 생성된다.

    refvar1 = 객체1;
    refvar2 = null;
    
    refvar1 == null     결과 : false
    refvar1 != null     결과 : true
    
    refvar2 == null     결과 : true
    refvar2 != null     결과 : false
    
+ 프로그램 실행 도중에 발생하는 오류를 예외(Exception)라고 부른다. 예외는 사용자의 잘못된 입력으로 발생할 수도 있고,
프로그래머가 코드를 잘못 작성해서 발생할 수도 있다.   
+ 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나로 NullPointerException이 있다. 이 예외는 참조 타입 변수를 잘못 사용하면 발생된다.
  
참조 타입 변수가 null을 가지고 있을 경우, 참조 타입 변수는 사용할 수 없다. 그러나 프로그래머의 실수로 null 값을 가지고 있는 참조 타입
변수를 사용하면 NullPointerException이 발생한다.

    int[] intArray = null;
    intArray[0] = 10;         //NullPointerException
    
    String str = null;
    system.out.println("총 문자수 : " +str.length());     //NullPointerException

+ intArry는 배열 타입 변수이므로 참조 타입 변수이다. 그래서 null로 초기화가 가능한데 이 상태에서 intArray[0]에 10을 
저장하려고 하면 NullPointerException이 발생한다. 이유는 intArray 변수가 참조하는 배열 객체가 없기 때문이다.

+ str 변수는 String 클래스 타입이므로 참조 타입이다. 따라서 str 변수도 null로 초기화가 가능하다. 이 상태에서 스트링 객체의 length()라는
메소드를 호출하면 NullPointerException이 발생한다. 이유는 str 변수가 참조하는 String 객체가 없기 때문이다.
+ 프로그램 실행 도중 NullPointerException이 발생하면, 예외가 발생된 곳에서 객체를 참조하지 않은 상태로 참조 타입 변수를 사용하고 있음을 알아야 한다.

### String 타입
+ 자바는 문자열을 String 변수에 저장하기 때문에 다음과 같이 String 변수를 우선 선언해야 한다.
+ String 변수에 문자열을 저장하려면 큰 따옴표로 감싼 문자열 리터럴을 대입하면 된다.
  
.

    String name;
    name = "Java";
    String hobby = "자바";

+ 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.
  
.

    String name1 = "Java";
    String name2 = "Java";
    name1 == name2           결과값 true
    //동일한 String 객체 참조
    
+ 서로 다른 String 객체를 참조해야 한다면 new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다.
+ 문자열만을 비교할 때에는 String 객체의 equals() 메소드를 사용해야 한다.
  
.

    String name1 = new String("Java");
    String name2 = new String("Java");
    name1 == name2                    결과값 false
    //서로 다른 객체 참조
    str1.equals(str2);                결과값 true
    //문자열만 비교


다음 코드 처럼 hobby 변수가 String 객체를 참조하였으나, null을 대입함으로써 더 이상 String 객체를 참조하지 않도록 할 수도 있다.

    String hobby = "여행"
    hobby = null;

참조를 잃은 객체는 쓰레기 객체로 취급하고 쓰레기 수집기(Gabage Collector)를 구동시켜 메모리에서 자동 제거한다.


### 배열 타입
+ 변수는 한 개의 데이터만 저장할 수 있다. 따라서 저장해야 할 데이터의 수가 많아지면 그만큼 많은 변수가 필요하다. 
이와 같은 방법은 매우 비효율적이고 지루한 코딩이 된다. 배열은 같은 타입의 데이터를 연속된 공간에 나열시키고, 
각 데이터에 인덱스(index)를 부여해 이와 같은 문제를 해결한다. 

<img src="http://pds21.egloos.com/pds/201312/08/39/f0183439_52a4257612177.png"></img>

예를 들어 score[0]은 71, score[1]은 80, score[2]는 64 값을 가진다.   

+ 배열은 같은 타입의 데이터만 저장할 수 있다. int 배열은 int 값만 저장 가능하고. String 배열은 문자열만 저장 가능하다.
+ 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다. 만약 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch)
컴파일 오류가 발생한다.
+ 배열의 또 다른 특징은 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.

배열을 사용하기 위해서는 우선 배열 변수를 선언해야 한다.

    int[] intArray;
    int intArray[];


+ 대괄호 []는 배열 변수를 선언하는 기호로 사용되는데, 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다.
+ 배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
+ 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화될 수 있다.
+ 만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다.

배열 항목에 저장될 값의 목록이 있다면, 다음과 같이 간단하게 배열 객체를 만들 수 있다.

    데이터타입[] 변수 = {값0, 값1, 값2 ...};

중괄호 {}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴한다.   
배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.

    String[] names = { "Java", "C", "C++" };

이렇게 생성된 배열에서 "Java"는 names[0], "C"는 names[1], "C++"은 names[2]로 읽을 수 있다.   
names[0]의 "Java"를 "C#"으로 바꾸고 싶다면 다음과 같이 대입 연산자를 사용하면 된다.

    names[0] = "C#";

값의 목록으로 배열 객체를 생성할 때 주의할 점은 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다.   
배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 new 연산자를 사용해서 값 목록을 지정해주면 된다.

    String[] names = null;
    names = new String[] {"Java", "C", "C++"};
    
메소드의 배개값이 배열일 경우에도 마찬가지다. 매개 변수로 int[] 배열이 선언된 add() 메소드가 있을 경우, 값 목록으로 배열을 생성함과 동시에
add() 메소드의 매개값으로 사용하고자 할 때는 반드시 new 연산자를 사용해야 한다.

    int add(int[] scores) {...}
    ---------------------------
    int result = add( {95, 85, 90} );     //컴파일 에러
    int result = add( new int[] {95, 85, 90} );
    
### new 연산자로 배열 생성
값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 배열 객체를 생성시킬 수 있다.

    타입[] 변수 = new 타입[길이];
    int[] intArray = new int[5];    //길이가 5인 배열 생성

길이는 배열이 저장할 수 있는 값의 수를 말한다.
배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.

    int[] scores = new int[3];
    scores[0] = 83;
    scores[1] = 70;
    scores[2] = 89;
    
### 배열 길이
+ 배열의 길이란 배열에 저장할 수 있는 전체 항목 수를 말한다.
+ 코드에서 배열의 길이를 얻으려면 다음과 같이 배열 객체의 length 필드를 읽으면 된다.
  
.
    int[] intArray = {10, 20, 30};
    int num = intArray.length;
배열 intArray가 3개의 값을 가지고 있기 때문에 변수 num에는 3이 저장된다.
length 필드는 for문을 사용해서 배열 전체를 루핑할 때 매우 유용하게 사용할 수 있다.

### 다차원 배열
지금까지 살펴본 배열은 값 목록으로 구성된 1차원 배열이다. 이와는 달리 값들이 행과 열로서 구성된 배열을 2차원 배열이라고 한다.   
2차원 배열은 수학의 행렬을 떠올리면 되는데, 가로 인덱스와 세로 인덱스를 사용한다.   
예를 들어 2행 3열을 만들기 위해 다음과 같은 코드를 사용한다.

<img src = "https://t1.daumcdn.net/cfile/tistory/236A7E405642F1682C"></img>

    int[][] scores = new int[2][3];

배열 변수인 scores는 길이 2인 배열 A를 참조한다. 배열 A의 scores[0]은 다시 길이 3인 배열 B를 참조한다.
그리고 scores[1] 역시 길이 3인 배열 C를 참조한다.   
scores[0]과 scores[1]은 모두 배열을 참조하는 변수 역할을 한다. 따라서 각 배열의 길이는 다음과 같이 얻을 수 있다.

    scores.length     //2(배열 A의 길이)
    scores[0].length  //3(배열 B의 길이)
    scores[1].length  //3(배열 C의 길이)

사용 방식은 행렬과 동일하다. scores[0][1]은 배열 B의 인덱스 1 값을 뜻한다. 수학 행렬에서는 (0,1) 값이라고 볼 수 있다.   
자바는 일차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에 수학 행렬 구조가 아닌 계단식 구조를 가질 수 있다.

    int[][] scores = new int[2][];
    scores[0] = new int[2];  0 1
    scores[0] = new int[3];  0 1 2

이 경우 배열 학목의 수를 조사해보면 다음과 같다.

    scores.length           //2(배열 A의 길이)
    scores[0].length        //2(배열 B의 길이)
    scores[1].length        //3(배열 C의 길이)

이런 형태의 배열에서 주의할 점은 정확한 배열의 길이를 알고 인덱스를 사용해야 한다. scores[0][2]는 ArrayIndexOutOfBoundsException을 발생시킨다.   
이유는 배열 B 객체의 마지막 인덱스는 1이기 때문이다.   
그룹화 된 값 목록을 가지고 있다면 다음과 같이 중괄호 안에 다시 중괄호를 사용해서 값 목록을 나열하면 된다.

    int[][] scores = { {95,80}, {92, 96} };
    
    int score = scores [0][0] //95
    int score = scores [1][1] //96


### 객체를 참조하는 배열

+ 기본 타입 배열은 각 항목에 직접 값을 갖고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있다.
+ 예를 들어 String은 클래스 타입이므로 String[] 배열은 각 항목에 문자열이 아니라, String 객체의 주소를 가지고 있다.
  
.

    String strArray = new String[3];
    strArray[0] = "java";               //String 객체 생성 되고 strArray[0]에는 String 객체의 주소가 저장
    strArray[1] = "c++";                
    strArray[2] = "c#";                 

+ 따라서 String[] 배열의 항목도 결국 String 변수와 동일하게 취급되어야 한다.
+ 예를 들어 문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드를 사용해야 한다.
    
.

    String [] strArray = new String[3];
    strArray[0] = "Java";
    strArray[1] = "Java";
    strArray[2] = new String("Java");
    
    strArray[0] == strArray[1]   //true (같은 객체를 참조)
    strArray[0] == strArray[2]   //false (다른 객체를 참조)
    strArray[0].equals(strArray[2])  //true( 문자열이 동일)


### 배열 복사
+ 배열은 한번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고
이전 배열로부터 항목 값들을 복사해야 한다.
+ 배열 간의 항목 값들을 복사하려면 for문을 사용하거나 System.arraycopy()메소드를 사용하면 된다.
    
.

    System.arraycopy(arr1, 0 ,0rr2 ,0 ,arr1.length);
    

### 향상된 for문
+ 자바 5부터 향상된 for문을 제공한다.
+ 향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다. 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
    
.   
    for(타입 변수 : 배열){
            실행문;
    }
    
for 문이 처음 실행될때 배열에서 가져올 첫 번째 값이 존재하는지 평가한다. 가져올 값이 존재하면 해당 값을 변수에 저장한다.
그리고 실행문을 실행한다. 이 과정을 반복하다가 배열에서 가져올 다음 항목이 없으면 for문이 종료된다.


## 열거 타입
+ 데이터 중에는 몇 가지로 한정된 값만을 갖는 경우가 있다. 예를 들어 요일에 대한 데이터는 월, 화, 수, 목, 금, 토, 일 이라는 일곱 개의 값만을 갖고, 계절에 대한 데이터는 봄, 여름, 가을, 겨울이라는 네개의 값만을 가진다. 이와 같이 한정된 값만을 갖는 데이터 타입이 열거 타입 이다.
+ 열거 타입은 몇 개의 열거 상수 중에서 하나의 상수를 저장하는 데이터 타입이다.

### 열거 타입 선언
+ 열거 타입을 선언하기 위해서는 먼저 열거 타입의 이름을 정하고 열거 타입 이름으로 소스파일을 생성해야 한다.
+ 소스 파일의 내용으로는 열거 타입 선언이 온다. public enum 키워드는 열거 타입을 선언하기 위한 키워드 이다.
+ 열거 타입을 선언했다면 열거 상수를 선언하면 된다. 열거 상수는 열거의 값으로 사용된다. 관례적으로 열거 상수는 모두 대문자로 작성한다.
    
.

    public enum Week {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, ...}

### 열거 타입 변수
+ 열거 타입을 선언했다면 열거 타입을 사용할 수 있다. 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.
+ 열거 상수는 단독으로 사용 할 수는 없고 반드시 열거타입.열거상수로 사용된다.
+ 열거 타입 변수도 참조 타입이기 때문에 null값을 저장할 수 있다.

.
    Week today = Week.SUNDAY;
    Week birthday = null;

열거 타입 변수 today 는 스택 영역에 생성된다. today에 저장되는 값은 Week.SUNDAY 열거 상수가 참조하는 객체의 번지이다. 따라서 열거 상수 Week.SUNDAY와 today 변수는 서로 같은 Week 객체를 참조하게된다.

### 열거 객체의 메소드

+ name() 메소드는 열거 객체가 가지고 있는 문자열을 리턴한다. 이때 리턴되는 문자열은 열거 타입을 정의할 때 사용한 상수 이름과 동일하다.
  
.
    
    Week today = Week.SUNDAY;
    String name = today.name();   //SUNDAY를 리턴하여 name 변수에 저장

+ ordinal() 메소드는 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다. 열거 객체의 순번은 타입을 정의할 때 주어진 순번을 말하는데, 0번 부터 시작한다.
  
.
    
    Week toay = Week.SUNDAY;
    int ordinal = today.ordinal();        //6을 리턴해서 ordinal 변수에 저장

+ compareTo() 메소드는 매개값으로 주어진 열거 객체를 기준으로 전후로 몇번째위치하는 지를 비교한다. 순번이 빠르다면 음수를, 늦다면 양수가 리턴된다.
  
.
    
    Week day1 = Week.MONDAY;
    Week day2 = Week.WEDNESDAY;
    int result1 = day1.compareTo(day2);     //day1이 day2 보다 2만큼 앞에 있으므로 -2가 나온다.
    int result2 = day2.compareTo(day1);     //day2가 day1 보다 2만큼 뒤에 있으므로 2가 나온다.
    
+ valueOf() 메소드는 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.























