chapter06.

# 상속

## 상속 개념

현실에서 상속(Inheritance)은 부모가 자식에게 물려주는 행위를 말한다. 자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용할 수 있다.   
객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다. 프로그램에서는 부모 클래스를 상위 클래스라고 부르기도 하고, 
자식 클래스를 하위 클래스, 또는 파생 클래스라고 부른다.

상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.

field1, field2, method1(), method2()를 가지는 클래스를 작성한다고 생각해보자. 4개를 모두 처음부터 작성하는 것보다는 field1과 method1()을 가지고
있는 클래스가 있다면 이것을 상속하고, field2와 method2()만 추가 작성하는 것이 보다 효율적이고 개발 시간을 절약시켜준다.

상속을 해도 부모 클래스의 모든 필드와 메소드들을 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 
상속 대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.
그 이외의 경우는 모두 상속의 대상이 된다.

상속을 이용하면 클래스의 수정을 최소화시킬 수도 있다. 부모 클래스의 수정으로 모든 자식 클래스들의 수정 효과를 가져오기 때문에 
유지 보수 시간을 최소화시켜준다.

## 클래스 상속
현실에서 상속은 부모가 자식을 선택해서 물려주지만, 프로그램에서는 자식이 부모를 선택한다.
자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술한다.

    Class 자식클래스 extends 부모클래스 {
    
    }
    
다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다. 즉 여러 개의 부모 클래스를 상속할 수 없다. 그러므로 extends 뒤에는 단 하나의 부모 클래스만
와야 한다.


## 부모 생성자 호출
현실에서 부모 없는 자식이 있을 수 없듯이 자바에서도 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.
아래 코드는 DmbCellPhone 객체만 생성하는 것처럼 보이지만, 사실은 내부적으로 부모인 CellPhone 객체가 먼저 생성되고, DmbCellPhone 객체가 생성된다.

    DmbCellPhone dmbCellPhone = new DmbCellPhone();
    
모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. 
예를 들어 DmbCellPhone의 생성자가 명시적으로 선언되지 않았다면 컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.

    public DmbCellPhone(){
      super();
    }
    
첫 줄에 super();가 추가된 것을 볼 수 있다. super()는 부모의 기본 생성자를 호출한다. 즉 CellPhone 클래스의 다음 생성자를 호출한다.

    public CellPhone() {
    }


## 메소드 재정의
부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을
수도 있다. 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다. 
자바는 이런 경우를 위해 메소드 오버라이딩(Overriding) 기능을 제공한다.

### 메소드 재정의(@Override)
메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다. 메소드가 오버라이딩
되었다면 부모 객체의 메소드는 숨겨지기 때문에, 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.

메소드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.

+ 부모의 메소드와 동일한 시그니처(리턴타입, 메소드이름, 매개 변수 리스트)를 가져야 한다.
+ 접근 제한을 더 강하게 오버라이딩할 수 없다. 반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면
  재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질 수 있다.
+ 새로운 예외(Exception)를 throws할 수 없다.




























