chapter06.

# 상속

## 상속 개념

현실에서 상속(Inheritance)은 부모가 자식에게 물려주는 행위를 말한다. 자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용할 수 있다.   
객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다. 프로그램에서는 부모 클래스를 상위 클래스라고 부르기도 하고, 
자식 클래스를 하위 클래스, 또는 파생 클래스라고 부른다.

상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.

field1, field2, method1(), method2()를 가지는 클래스를 작성한다고 생각해보자. 4개를 모두 처음부터 작성하는 것보다는 field1과 method1()을 가지고
있는 클래스가 있다면 이것을 상속하고, field2와 method2()만 추가 작성하는 것이 보다 효율적이고 개발 시간을 절약시켜준다.

상속을 해도 부모 클래스의 모든 필드와 메소드들을 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 
상속 대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.
그 이외의 경우는 모두 상속의 대상이 된다.

상속을 이용하면 클래스의 수정을 최소화시킬 수도 있다. 부모 클래스의 수정으로 모든 자식 클래스들의 수정 효과를 가져오기 때문에 
유지 보수 시간을 최소화시켜준다.

## 클래스 상속
현실에서 상속은 부모가 자식을 선택해서 물려주지만, 프로그램에서는 자식이 부모를 선택한다.
자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술한다.

    Class 자식클래스 extends 부모클래스 {
    
    }
    
다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다. 즉 여러 개의 부모 클래스를 상속할 수 없다. 그러므로 extends 뒤에는 단 하나의 부모 클래스만
와야 한다.


## 부모 생성자 호출
현실에서 부모 없는 자식이 있을 수 없듯이 자바에서도 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.
아래 코드는 DmbCellPhone 객체만 생성하는 것처럼 보이지만, 사실은 내부적으로 부모인 CellPhone 객체가 먼저 생성되고, DmbCellPhone 객체가 생성된다.

    DmbCellPhone dmbCellPhone = new DmbCellPhone();
    
모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. 
예를 들어 DmbCellPhone의 생성자가 명시적으로 선언되지 않았다면 컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.

    public DmbCellPhone(){
      super();
    }
    
첫 줄에 super();가 추가된 것을 볼 수 있다. super()는 부모의 기본 생성자를 호출한다. 즉 CellPhone 클래스의 다음 생성자를 호출한다.

    public CellPhone() {
    }


## 메소드 재정의
부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을
수도 있다. 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다. 
자바는 이런 경우를 위해 메소드 오버라이딩(Overriding) 기능을 제공한다.

### 메소드 재정의(@Override)
메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다. 메소드가 오버라이딩
되었다면 부모 객체의 메소드는 숨겨지기 때문에, 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.

메소드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.

+ 부모의 메소드와 동일한 시그니처(리턴타입, 메소드이름, 매개 변수 리스트)를 가져야 한다.
+ 접근 제한을 더 강하게 오버라이딩할 수 없다. 반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면
  재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질 수 있다.
+ 새로운 예외(Exception)를 throws할 수 없다.

### 부모 메소드 호출(super)
자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용된다. 그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있다.

## final 클래스와 final 메소드
final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다. final 키워드는 해당 선언이 최종 상태이고, 결코 수정될 수 없읍을 뜻한다. 클래스와 메소드 선언시에 final 키워드가 지정되면 상속과 관련이 있다.

### 상속할 수 없는 final 클래스

클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 클래스를 만들 수 없다는 것이다.

final 클래스의 대표적인 예는 자바 표준 API에서 제공하는 String 클래스이다. String 클래스는 final 클래스로 선언되어 있기 때문에 자식 클래스를 만들수 없다.

    public final class String {...}
    
    public class NewString extends String {...} //상속이 불가능


### 오버라이딩할 수 없는 final 메소드

메소드를 선언할 때 final 키워드를 붙이게 되면 이 메소드는 최종적인 메소드이므로 오버라이딩할 수 없는 메소드가 된다. 즉 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없다는 것이다.

    public final void method(...) {...}


## protected 접근 제한자
protected는 public과 default 접근 제한의 중간 쯤에 해당한다. 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용한다.

    package packge1;
    public class A {
      protected String field;
    }
    
    
    package2;
    import package1.A;
    
    public class D extends A{
      public D() {
      super();
      thiis.field = "value";
    }
    
    package2
    import package1.A;
    public class C {
      A a = new A();         /X
      a.field = "value";     /X
    }
    
## 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.

자바는 다형성을 위해 부모 클래스로 타입 변환을 허용한다. 즉 부모 타입에 모든 자식 객체가 대입될 수 있다. 이것을 이용하면 객체는 부품화가 가능하다.

### 자동 타입 변환(Promotion)
자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다. 자동 타입 변환은 다음과 같은 조건에서 일어난다.

    부모클래스 변수 = 자식클래스타입;

자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것이다.

    Cat cat = new Cat();
    Animal animal = cat;    //Animal animal = new cat();도 가능하다
    cat == animal // true
    
cat과 animal 변수를 == 연산해보면 true가 나오는데, 참조 변수의 == 연산은 참조 주소값이 같을 경우 true를 산출하므로
두 변수가 동일한객체를 참조하고 있다는 뜻이다.

부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다.

그러나 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 대신 호출된다. 이것은 다형성(Polymorphism)과 관련이 있기 때문에 매우 중요한 성질이므로 잘 알아두어야 한다.

### 필드의 다형성

그렇다면 왜 자동 타입 변환이 필요할까? 그냥 자식 타입으로 사용하면 될 것을 부모 타입으로 변환해서 사용하는 이유가 무엇일까? 그것은 다형성을 구현하는 기술적 방법 때문이다.

다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말한다. 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.

타이어 객체는 언제든지 성능이 좋은 다른 타이어 객체로 교체할 수 있어야 한다. 새로 교체되는 타이어 객체는 기존 타이어와 사용 방법은 동일하지만 실행 결과는 더 우수하게 나와야 할 것이다. 이것을 프로그램으로 구현하기 위해서는 상속과 오버라이딩, 그리고 타입 변환을 이용하는 것이다.

부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일할 것이고, 자식 클래스는 부모의 메소드를 오버라이딩 해서 메소드의 실행 내용을 변경함으로써 더 우수한 실행 결과가 나오게 할 수 있다.

    class Car{
      Tire frontLeftTire = new Tire();
      Tire frontrightTire = new Tire();
      Tire backLeftTire = new Tire();
      Tire backrightTire = new Tire();
      
      void run() {...}
    }

Car 클래스는 4개의 Tire 필드를 가지고 있다. Car 클래스로부터 Car 객체를 생성하면 4개의 Tire 필드에 각각 하나씩 Tire 객체가 들어가게 된다. 그런데, frontRightTire와 backLeftTire를 HankookTire와 KumhoTire로 교체할 필요성이 생겼다. 이경우 다음과 같은 코드를 사용해서 교체할 수 있다.

    Car myCar = new Car();
    myCar.frontRightTire = new HankookTire();
    myCar.backLeftTire = new KumhoTire();
    myCar.run();
    
Tire 클래스 타입인 frontRightTire와 backLeftTire는 원래 Tire 객체가 저장되어야 하지만, Tire의 자식 객체가 저장되어도 문제가 없다. 왜냐하면 자식 타입은 부모 타입으로 자동 타입 변환이 되기 때문이다.

frontRight와 backLeftTire에 Tire 자식 객체가 저장되어도 Car 객체는 Tire 클래스에 선언된 필드와 메소드만 사용하므로 전혀 문제가 되지 않는다. HankookTire와 KumhoTire는 부모인 Tire의 필드와 메소드를 가지고 있기 때문이다. Car 객체에 run() 메소드가 있고, run() 메소드는 각 Tire 객체의 roll() 메소드를 다음과 같이 호출한다고 가정해보자.

    void run() {
      frontLeftTire.roll();
      frontRightTire.roll();
      backLeftTire.roll();
      backRightTire.roll();
    }

frontRightTire와 backLeftTire를 교체하기 전에는 Tire 객체의 roll() 메소드가 호출되지만, HankookTire와 KumhoTire로 교체가 된 후에는 HankookTire와 KumhoTire 객체의 roll() 메소드가 호출된다. 이와 같이 자동 타입 변환을 이용해서 Tire 필드값을 교체함으로써 Car의 run() 메소드 수정 없이도 다양한 roll() 메소드의 실행 결과를 얻게 된다.


### 하나의 배열로 객체 관리

이전 예제에서 Car 클래스에 4개의 타이어 객체를 4개의 필드로 각각 저장했다. 우리는 동일한 타입의 값들은 배열로 관리하는 것이 유리하다는 것을 알고 있다. 그렇다면 타이어 객체들도 타이어 배열로 관리하는 것이 코드를 깔끔하게 만들어줄 것이다.

    Class Car {
      Tire[] tires = {
        new Tire("앞왼쪽", 6),
        new Tire("앞오른쪽", 2),
        new Tire("뒤왼쪽", 3),
        new Tire("뒤오른쪽", 4),
      };
    }


frontLeftTire 는 tires[0], frontRightTire는 tires[1], backLeftTire는 tires[2], backRightTire는 tires[3]과 같이 인덱스로 표현되므로 대입이나 제어문에서 활용하기 매우 쉽다. 예를 들어 인덱스 1을 이용해서 앞오른쪽 타이어를 KumhoTire로 교체하기 위해 다음과 같이 작성할 수 있다.

    tires[1] = new KumhoTire("앞오른쪽", 13);
    
tires 배열의 각 항목은 Tire 타입이므로 자식 객체인 KumhoTire를 대입하면 자동 타입 변환이 발생하기 때문에 아무런 문제가 없다. 배열의 타입은 Tire이지만 실제 저장 항목이 Tire의 자식 객체라면 모두 가능하다. 상속 관계에 있는 객체들을 배열로 관리하면 제어문에서 가장 많이 혜택을 본다.

전체 타이어의 roll() 메소드를 호출하는 Car 클래스의 run() 메소드는 다음과 같이 for문으로 작성할 수 있다.


    int run() {
      System.out.println("자동차가 달립니다");
      for(int i=0; i<tires.length; i++){
        if(tires[i].roll() == false){
          stop();
          return (i+1);
        }
      }
      return 0;
    }


### 매개 변수의 다형성

자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다. 메소드를 호출할 때에는 매개 변수의 타입과 동일한 매개값을 지정하는 것이 정석이지만, 매개값을 다양화하기 위해 매개 변수에 자식 타입 객체를 지정할 수도 있다.

    Class Driver {
      void drive(Vehicle vehicle){
        vehicle.run();
      }
    }

Driver 클래스에는 drive() 메소드가 정의되어 있는데 Vehicle 타입의 매개 변수가 선언되어 있다.








